package main
import "fmt"
import "math"
import "regexp"

var label int64 = 0 // distinctive number for a label

var seen_variable_to_offset = map[string]int64{"_": 0} // The offset of named variables
var argument_indices = []string{"%rdi", "%rsi", "%rdx", "%rcx", "%r8", "%r9"} // The arguments of the functions

func ast_to_asm_program(program * Program) string {
	asm := ""
	prev_func_name := "" // If the number of the functions is more than 2, this variable is needed to define another function.
	for i, def := range program.defs {
		if definition, ok := def.(*DefFun); ok {
			local_label := label
			/* define functions */
			if (i == 0){
				asm += fmt.Sprintf("	.text\n")
				asm += fmt.Sprintf("	.globl	%s\n", definition.name)
				asm += fmt.Sprintf("	.type	%s, @function\n", definition.name)
			} else {
				asm += fmt.Sprintf(".LFE%d:\n", local_label-1)
				asm += fmt.Sprintf("	.size %s, .-%s\n", prev_func_name, prev_func_name)
				asm += fmt.Sprintf("	.globl	%s\n", definition.name)
				asm += fmt.Sprintf("	.type	%s, @function\n", definition.name)
			}
			definition_to_asm(definition, &asm) 
			seen_variable_to_offset = map[string]int64{"_": 0}
			prev_func_name = definition.name
		}
	}
	// "this is an assembly code generated by minc compiler ...\n"
	// panic("YOU MUST IMPLEMENT go/minc/minc_cogen.go:ast_to_asm_program")
	return asm
}

func definition_to_asm(definition *DefFun, asm *string){
	*asm += gen_function_prologue(definition) 
	asm_body := gen_function_body(definition) // glow body
	asm_epilogue := gen_function_epilogue() // glow epilogue
	*asm += asm_body
	*asm += asm_epilogue
	// Remove reduntant instructions
	*asm = delete_variable_read_instruction_redundancy(*asm)
	*asm = delete_extract_variable_address_instruction_redundancy(*asm)
	*asm = convert_efficient_binary_operator(*asm)
	*asm = convert_pushq_popq_to_movq(*asm)
	*asm = delete_redundant_moveq(*asm)
}

func delete_variable_read_instruction_redundancy(asm string) string {
	/*
	movq %rbp, %rax
	subq $40, %rax
	movq (%rax), %rax
	pushq %rax
	equals 

	pushq -40(%rbp)
	*/
	// define regexp
	pattern := `movq %rbp, %rax\s*subq \$(\d+), %rax\s*movq \(%rax\), %rax\s*pushq %rax`
	re := regexp.MustCompile(pattern)

	// 
	replacement := func(match []string) string {
		number := match[1]
		return fmt.Sprintf("pushq -%s(%%rbp)", number)
	}
	code := re.ReplaceAllStringFunc(asm, func(s string) string {
		matches := re.FindStringSubmatch(s)
		if len(matches) > 0 {
			return replacement(matches)
		}
		return s
	})

	return code
}

func delete_extract_variable_address_instruction_redundancy(asm string) string {
	/*
	movq %rbp, %rax
	subq $8, %rax
	pushq %rax

	equals 

	leaq -8(%rbp), %rax
	pushq %rax
	*/
	pattern := `movq %rbp, %rax\s*subq \$(\d+), %rax\s*pushq %rax`
	re := regexp.MustCompile(pattern)
	// 
	replacement := func(match []string) string {
		number := match[1]
		return fmt.Sprintf("leaq -%s(%%rbp), %%rax\n	pushq %%rax", number)
	}
	code := re.ReplaceAllStringFunc(asm, func(s string) string {
		matches := re.FindStringSubmatch(s)
		if len(matches) > 0 {
			return replacement(matches)
		}
		return s
	})

	return code
}

func convert_efficient_binary_operator(asm string) string {
	/*
	pushq -56(%rbp)
	pushq -64(%rbp)
	popq %rdi
	popq %rax
	imulq %rdi, %rax

	equals
	
	movq -56(%rbp), %rax
	movq -64(%rbp), %rdi
	imulq %rdi, %rax
	*/
	pattern := `pushq\s+([^\s]+)\s*pushq\s+([^\s]+)\s*popq\s+%rdi\s*popq\s+%rax\s*([a-z]+q?)\s+([^\s]+),\s+([^\s]+)`
	re := regexp.MustCompile(pattern)
	replacement := func(match []string) string {
		address1 := match[1] 
		address2 := match[2]
		operation := match[3]
		operand1 := match[4]
		operand2 := match[5]
		return fmt.Sprintf("movq %s, %%rax\n	movq %s, %%rdi\n	%s %s, %s", address1, address2, operation, operand1, operand2)
	}
	code := re.ReplaceAllStringFunc(asm, func(s string) string {
		matches := re.FindStringSubmatch(s)
		if len(matches) > 0 {
			return replacement(matches)
		}
		return s
	})

	return code
}

func convert_pushq_popq_to_movq(asm string)string{
	/*
	push a
	pop b

	equals

	movq a b
	*/
	pattern := `pushq\s+([^\s]+)\s*popq\s+([^\s]+)`
	re := regexp.MustCompile(pattern)

	replacement := func(match []string) string {
		address := match[1]
		register := match[2]
		return fmt.Sprintf("movq %s, %s", address, register)
	}

	code := re.ReplaceAllStringFunc(asm, func(s string) string {
		matches := re.FindStringSubmatch(s)
		if len(matches) > 0 {
			return replacement(matches)
		}
		return s
	})
	return code
}

func delete_redundant_moveq(asm string) string {
	pattern := `movq\s+%(\w+),\s+%(\w+)\s*`
	re := regexp.MustCompile(pattern)
	replacement := func(match []string) string {
		source := match[1]
		destination := match[2]
		if source == destination {
			return ""
		}
		return match[0]
	}
	code := re.ReplaceAllStringFunc(asm, func(s string) string {
		matches := re.FindStringSubmatch(s)
		if len(matches) > 0 {
			return replacement(matches)
		}
		return s
	})
	return code
}

func gen_function_prologue(definition *DefFun) string {
	local_label := label
	asm := ""
	asm += fmt.Sprintf("%s:\n", definition.name)
	asm += fmt.Sprintf(".LFB%d:\n", local_label)
	label += 1
	asm += "	pushq	%rbp\n" // %rbpが関数の開始アドレスを指すようになる
	asm += "	movq	%rsp, %rbp\n" // %rspがスタックの先頭を指すようになる
	return asm
}

func gen_function_body(definition *DefFun) string {
	// definition = type_expr identifier "(" parameter_list ")" compound_stmt 
	asm := ""
	params := definition.params
	// paramsに関する処理を行う -> 全て%rbpとのoffsetで表現
	for i, param := range params {
		max_offset := get_max_offset(seen_variable_to_offset)
		offset := max_offset + 8
		seen_variable_to_offset[param.name] = offset
		if (i < len(argument_indices)){
			asm += fmt.Sprintf("	pushq %s\n", argument_indices[i])
		} else {
			asm += fmt.Sprintf("	pushq %d(%%rbp)\n", 8*(i-5+1)) // i >= len(argument_indices) の範囲は16(%rbp), 24(%rbp), ...にある
		}
	}
	stmt := definition.body
	asm += gen_stmt(stmt, )
	return asm
}

func gen_function_epilogue() string {
	// 終了処理をする。
	// %rbpの値を%rspにコピー, %rbpを現在呼び出されている関数よりも前の%rbpの値に
	asm := "	movq %rbp, %rsp\n" 
	asm += "	popq	%rbp\n" 
	asm += "	ret\n"
	return asm
}

func gen_stmt(stmt Stmt,) string {
	// pattern matching for stmt
	asm := ""
	switch stmt := stmt.(type){
		case *StmtEmpty:
			return ""
		case *StmtContinue:
			return ""
		case *StmtBreak:
			return ""
		case *StmtReturn:
			asm += gen_expr(stmt.expr,true)
			asm += "	popq %rax\n" 
			asm += gen_function_epilogue()
			return asm
		case *StmtExpr:
			asm += gen_expr(stmt.expr,false)
			return asm
		case *StmtCompound:
			for _, decl := range stmt.decls {
				asm += gen_decls(decl)
			}
			for _, s := range stmt.stmts {
				asm += gen_stmt(s)
			}
			// 0個以上のDeclとStmtに関して処理を行う
			return asm
		case *StmtIf:
			/*
			if (stmt.cond) stmt.then_stmt else stmt.else_stmt
			のコンパイル方法は
			stmt.condをコンパイルしたコード // スタックトップに結果が入っているはず
  			popq %rax
  			cmpq $0, %rax
  			je  .LelseXXX
  			stmt.then_stmtをコンパイルしたコード
  			jmp .LendXXX
			.LelseXXX
  			stmt.else_stmtをコンパイルしたコード
			.LendXXX
			*/
			local_label := label
			label += 1
			asm += gen_expr(stmt.cond,false)
			asm += "	popq %rax\n"
			asm += "	cmpq $0, %rax\n"
			asm += fmt.Sprintf("	je  .Lelse%d\n", local_label)
			asm += gen_stmt(stmt.then_stmt)
			asm += fmt.Sprintf("	jmp  .Lend%d\n", local_label)
			asm += fmt.Sprintf(".Lelse%d:\n", local_label)
			asm += gen_stmt(stmt.else_stmt)
			asm += fmt.Sprintf(".Lend%d:\n", local_label)
			return asm
		case *StmtWhile:
			/*
			while (stmt.cond) stmt.body
			のコンパイル方法
			.LbeginXXX:
  			stmt.condをコンパイルしたコード
  			popq %rax
  			cmpq $0, %rax
  			je  .LendXXX
  			stmt.bodyをコンパイルしたコード
  			jmp .LbeginXXX
			.LendXXX:
			*/
			local_label := label
			label += 1
			asm += fmt.Sprintf(".Lbegin%d:\n", local_label)
			asm += gen_expr(stmt.cond,false)
			asm += "	popq %rax\n"
			asm += "	cmpq $0, %rax\n"
			asm += fmt.Sprintf("	je .Lend%d\n", local_label)
			asm += gen_stmt(stmt.body)
			asm += fmt.Sprintf("	jmp .Lbegin%d\n", local_label)
			asm += fmt.Sprintf(".Lend%d:\n", local_label)
			return asm
		default:
			return ""
	}
}

func gen_expr(expr Expr,is_return bool) string {
	asm := ""
	switch expr := expr.(type){
		case *ExprIntLiteral:
			asm += fmt.Sprintf("	pushq $%d\n", expr.val) 
			return asm
		case *ExprId:
			offset, ok := seen_variable_to_offset[expr.name]
			if !ok {
				max_offset := get_max_offset(seen_variable_to_offset)
				offset = max_offset + 8
				seen_variable_to_offset[expr.name] = offset
			}
			// write a variable address in %rax
			asm += gen_lval(offset)
			// finished to write a variable
			// read from a variable
			asm += gen_read_lval()
			return asm
		case *ExprOp:
			switch expr.op {
				// Calculate the left side of AST and then calculate the right side of AST if expr.op is a binary operator. 
				case "+":
					if (len(expr.args) == 1){
						// unary op
						asm += "	pushq $0\n"
						asm += gen_expr(expr.args[0],is_return)
					} else if (len(expr.args) == 2){
						// binary op
						asm += gen_expr(expr.args[0],is_return)
						asm += gen_expr(expr.args[1],is_return)
					}
					asm += "	popq %rdi\n"
					asm += "	popq %rax\n"
					asm += "	addq %rdi, %rax\n"
					asm += "	pushq %rax\n"
					return asm
				case "-":
					if (len(expr.args) == 1){
						// unary op
						asm += "	pushq $0\n"
						asm += gen_expr(expr.args[0],is_return)
					} else if (len(expr.args) == 2){
						// binary op
						asm += gen_expr(expr.args[0],is_return)
						asm += gen_expr(expr.args[1],is_return)
					}
					asm += "	popq %rdi\n"
					asm += "	popq %rax\n"
					asm += "	subq %rdi, %rax\n"
					asm += "	pushq %rax\n"
					return asm
				case "*":
					asm += gen_expr(expr.args[0],is_return)
					asm += gen_expr(expr.args[1],is_return)
					asm += "	popq %rdi\n"
					asm += "	popq %rax\n"
					asm += "	imulq %rdi, %rax\n"
					asm += "	pushq %rax\n"
					return asm
				case "/":
					asm += gen_expr(expr.args[0],is_return)
					asm += gen_expr(expr.args[1],is_return)
					asm += "	popq %rdi\n"
					asm += "	popq %rax\n"
					asm += "	cqo\n"
					asm += "	idivq %rdi\n"
					asm += "	pushq %rax\n"
					return asm
				case "%":
					asm += gen_expr(expr.args[0],is_return)
					asm += gen_expr(expr.args[1],is_return)
					asm += "	popq %rdi\n"
					asm += "	popq %rax\n"
					asm += "	cqo\n"
					asm += "	idivq %rdi\n"
					asm += "	movq %rdx, %rax\n"
					asm += "	pushq %rax\n"
					return asm
				case "!":
					asm += gen_expr(expr.args[0],is_return)
					asm += "	popq %rax\n"
					asm += "	testq %rax, %rax\n"
					asm += "	sete	%al\n"
					asm += "	movzx	%al, %rax\n"
					asm += "	pushq %rax\n"
					return asm
				case "==":
					asm += gen_expr(expr.args[0],is_return)
					asm += gen_expr(expr.args[1],is_return)
					asm += "	popq %rdi\n"
					asm += "	popq %rax\n"
					asm += "	cmpq %rdi, %rax\n"
					asm += "	sete %al\n"
					asm += "	movzb %al, %rax\n"
					asm += "	pushq %rax\n"
					return asm
				case "!=":
					asm += gen_expr(expr.args[0],is_return)
					asm += gen_expr(expr.args[1],is_return)
					asm += "	popq %rdi\n"
					asm += "	popq %rax\n"
					asm += "	cmpq %rdi, %rax\n"
					asm += "	setne %al\n"
					asm += "	movzb %al, %rax\n"
					asm += "	pushq %rax\n"
					return asm
				case "<":
					asm += gen_expr(expr.args[0],is_return)
					asm += gen_expr(expr.args[1],is_return)
					asm += "	popq %rdi\n"
					asm += "	popq %rax\n"
					asm += "	cmpq %rdi, %rax\n"
					asm += "	setl %al\n"
					asm += "	movzb %al, %rax\n"
					asm += "	pushq %rax\n"
					return asm
				case "<=":
					asm += gen_expr(expr.args[0],is_return)
					asm += gen_expr(expr.args[1],is_return)
					asm += "	popq %rdi\n"
					asm += "	popq %rax\n"
					asm += "	cmpq %rdi, %rax\n"
					asm += "	setle %al\n"
					asm += "	movzb %al, %rax\n"
					asm += "	pushq %rax\n"
					return asm
				case ">":
					asm += gen_expr(expr.args[0],is_return)
					asm += gen_expr(expr.args[1],is_return)
					asm += "	popq %rdi\n"
					asm += "	popq %rax\n"
					asm += "	cmpq %rax, %rdi\n" // 上とは逆に
					asm += "	setl %al\n"
					asm += "	movzb %al, %rax\n"
					asm += "	pushq %rax\n"
					return asm
				case ">=":
					asm += gen_expr(expr.args[0],is_return)
					asm += gen_expr(expr.args[1],is_return)
					asm += "	popq %rdi\n"
					asm += "	popq %rax\n"
					asm += "	cmpq %rax, %rdi\n" // 上とは逆に
					asm += "	setle %al\n"
					asm += "	movzb %al, %rax\n"
					asm += "	pushq %rax\n"
					return asm
				case "=":
					asm += gen_expr(expr.args[0],is_return)
					read_string := gen_read_lval()
					asm = asm[:len(asm)-len(read_string)] // assignの場合readはしないのでreadの文字列分削除する
					asm += gen_expr(expr.args[1],is_return)
					asm += "	popq %rdi\n"
					asm += "	popq %rax\n"
					asm += "	movq %rdi, (%rax)\n"
					if (is_return == true){
						// return a = b = c = ...のような場合に対応する
						asm += "	pushq %rdi\n" 
					}
					return asm
				default:
					return ""
			}
		case *ExprCall:
			// 引数を逆順でスタックにプッシュ（レジスタとスタックを分ける必要あり）
			for i := len(expr.args) - 1; i >= 0; i-- {
				arg := expr.args[i]
				asm += gen_expr(arg,is_return)
				asm += "	popq %rax\n"
				if i >= len(argument_indices) {
					// スタックに引数を保存（7つ目以降）
					asm += "	pushq %rax\n" // 現在のstackより下に貯めておけばアクセス可能になる
				} else {
					// レジスタに引数を保存
					asm += fmt.Sprintf("	movq %%rax, %s\n", argument_indices[i])
				}
			}
			// 関数呼び出し
			asm += fmt.Sprintf("	call %s\n", expr.fun.ast_to_str_expr())
			// 返り値をスタックにプッシュ
			if len(expr.args) > len(argument_indices) {
				// argument_indicesを超えている分だけstackに蓄えられているのでここで余分なものは消しておく
				asm += fmt.Sprintf("	addq $%d, %%rsp\n", 8*(len(expr.args) - len(argument_indices)))
			}
			asm += "	pushq %rax\n"

			return asm
		case *ExprParen:
			return ""
		default:
			return ""
	}
}

func gen_decls(decl *Decl,) string {
	// 変数定義場所, TypeExprは変更しない
	asm := ""
	offset, ok := seen_variable_to_offset[decl.name]
	if !ok {
		max_offset := get_max_offset(seen_variable_to_offset)
		offset = max_offset + 8
		seen_variable_to_offset[decl.name] = offset
		asm += "	subq $8, %rsp\n" // 変数宣言用の領域確保
		asm += fmt.Sprintf("	movq $0, -%d(%%rbp)\n",offset)
	}
	return asm
}
/*
type Program struct {
	defs []Def
}
*/

// used by case *ExprId:
func get_max_offset(offsets map[string]int64) int64 {
    var max_offset int64 = math.MinInt64 // 最小の64ビット整数で初期化
    for _, offset := range offsets {
        if offset > max_offset {
            max_offset = offset
        }
    }
    return max_offset
}

func gen_lval(offset int64)string{
	// save the address of a variable to the top of the stack
	asm := ""
	asm += "	movq %rbp, %rax\n"
	asm += fmt.Sprintf("	subq $%d, %%rax\n", offset)
	asm += "	pushq %rax\n"
	return asm
}

func gen_read_lval()string{
	// save the value of a variable to the top of the stack
	asm := ""
	asm += "	popq %rax\n"
	asm += "	movq (%rax), %rax\n"
	asm += "	pushq %rax\n"
	return asm
}
